- name: Install dependencies
  apt:
    name: "{{ item }}"
    state: present
    update_cache: yes
  loop:
    - openjdk-17-jdk
    - awscli
    - unzip
    - jq
    - curl
    - git

- name: Install Docker
  shell: curl -fsSL https://get.docker.com | sh
  args:
    creates: /usr/bin/docker

- name: Add users to docker group
  user:
    name: "{{ item }}"
    groups: docker
    append: yes
  loop:
    - ubuntu
    - jenkins

- name: Add Jenkins repo and key
  shell: |
    curl -fsSL https://pkg.jenkins.io/debian-stable/jenkins.io.key | tee /usr/share/keyrings/jenkins-keyring.asc
    echo 'deb [signed-by=/usr/share/keyrings/jenkins-keyring.asc] https://pkg.jenkins.io/debian-stable binary/' | tee /etc/apt/sources.list.d/jenkins.list
    apt update
    apt install -y jenkins
  args:
    creates: /usr/bin/jenkins

- name: Enable and start Jenkins
  systemd:
    name: jenkins
    enabled: yes
    state: restarted

- name: Disable Jenkins setup wizard
  lineinfile:
    path: /etc/default/jenkins
    line: 'JAVA_ARGS="$JAVA_ARGS -Djenkins.install.runSetupWizard=false"'
    create: yes

# - name: Toggle CSRF protection (based on jenkins_csrf_enabled)
#   include_tasks: toggle_csrf.yml

- name: Ensure Jenkins init.groovy.d directory exists
  file:
    path: /var/lib/jenkins/init.groovy.d
    state: directory
    owner: jenkins
    group: jenkins
    mode: '0755'

- name: Add admin Groovy script
  template:
    src: ../templates/basic-security.groovy.j2
    dest: /var/lib/jenkins/init.groovy.d/basic-security.groovy
    owner: jenkins
    group: jenkins
    mode: '0644'

- name: Enable and start Jenkins
  systemd:
    name: jenkins
    enabled: yes
    state: restarted

- name: Wait for Jenkins to be available
  uri:
    url: "{{ jenkins_host }}/login"
    status_code: 200
    timeout: 300
    validate_certs: no
  register: jenkins_check
  until: jenkins_check.status == 200
  retries: 30
  delay: 10

- name: Download Jenkins CLI
  get_url:
    url: "{{ jenkins_host }}/jnlpJars/jenkins-cli.jar"
    dest: /tmp/jenkins-cli.jar
    mode: '0755'

- name: Wait for Jenkins to be available
  uri:
    url: "{{ jenkins_host }}/login"
    status_code: 200
    timeout: 300
    validate_certs: no
  register: jenkins_check
  until: jenkins_check.status == 200
  retries: 30
  delay: 10

- name: Install Jenkins plugins
  shell: |
    java -jar /tmp/jenkins-cli.jar -s {{ jenkins_host }} -auth {{ jenkins_user }}:{{ jenkins_password }} install-plugin {{ item }} -deploy
  loop:
    - workflow-aggregator
    - git
    - docker-workflow
    - blueocean
    - credentials-binding
    - aws-credentials
    - ssh-agent
    - credentials
    - plain-credentials
    - ssh-credentials
    - matrix-auth

- name: Restart Jenkins after installing plugins
  become: true
  service:
    name: jenkins
    state: restarted

- name: Create sample pipeline job
  template:
    src: ../templates/sample-pipeline-job.xml.j2
    dest: /tmp/sample-pipeline-job.xml

- name: Wait for Jenkins to be available
  uri:
    url: "{{ jenkins_host }}/login"
    status_code: 200
    timeout: 300
    validate_certs: no
  register: jenkins_check
  until: jenkins_check.status == 200
  retries: 30
  delay: 10

- name: Check if Jenkins job exists
  shell: |
    java -jar /tmp/jenkins-cli.jar -s {{ jenkins_host }} -auth {{ jenkins_user }}:{{ jenkins_password }} get-job {{ jenkins_pipeline }}
  register: job_check
  ignore_errors: true
  changed_when: false

# - name: Delete Jenkins job if it exists
#   shell: |
#     java -jar /tmp/jenkins-cli.jar -s {{ jenkins_host }} -auth {{ jenkins_user }}:{{ jenkins_password }} delete-job {{ jenkins_pipeline }}
#   when: job_check.rc == 0

- name: Create Jenkins job if it doesn't exist
  shell: |
    java -jar /tmp/jenkins-cli.jar -s {{ jenkins_host }} -auth {{ jenkins_user }}:{{ jenkins_password }} create-job {{ jenkins_pipeline }} < /tmp/sample-pipeline-job.xml
  when: job_check.rc != 0

- name: Wait for Jenkins to be available
  uri:
    url: "{{ jenkins_host }}/login"
    status_code: 200
    timeout: 300
    validate_certs: no
  register: jenkins_check
  until: jenkins_check.status == 200
  retries: 30
  delay: 10

- name: Get crumb and store cookie
  shell: |
    curl -c /tmp/jenkins_cookie.txt -s -u "{{ jenkins_user }}:{{ jenkins_password }}" \
      {{ jenkins_host }}/crumbIssuer/api/json
  register: crumb_output

- name: Parse Jenkins crumb
  set_fact:
    jenkins_crumb: "{{ (crumb_output.stdout | from_json).crumb }}"

- name: Ensure Jenkins token named 'terraform-token' is deleted before recreation
  shell: |
    # Get the list of current tokens
    TOKENS_JSON=$(curl -s -b /tmp/jenkins_cookie.txt \
      -u "{{ jenkins_user }}:{{ jenkins_password }}" \
      -H "Jenkins-Crumb: {{ jenkins_crumb }}" \
      "{{ jenkins_host }}/user/{{ jenkins_user }}/descriptorByName/jenkins.security.ApiTokenProperty/getTokenList")

    # Extract UUID of existing token named 'terraform-token'
    TOKEN_UUID=$(echo "$TOKENS_JSON" | jq -r '.data.tokenInfos[] | select(.name=="terraform-token") | .uuid')

    # If the token exists, delete it
    if [ -n "$TOKEN_UUID" ]; then
      curl -s -b /tmp/jenkins_cookie.txt \
        -u "{{ jenkins_user }}:{{ jenkins_password }}" \
        -H "Jenkins-Crumb: {{ jenkins_crumb }}" \
        --data "tokenUuid=$TOKEN_UUID" \
        "{{ jenkins_host }}/user/{{ jenkins_user }}/descriptorByName/jenkins.security.ApiTokenProperty/revoke"
    fi

    # Create the new token
    curl -s -b /tmp/jenkins_cookie.txt \
      -u "{{ jenkins_user }}:{{ jenkins_password }}" \
      -H "Jenkins-Crumb: {{ jenkins_crumb }}" \
      --data "newTokenName=terraform-token" \
      "{{ jenkins_host }}/user/{{ jenkins_user }}/descriptorByName/jenkins.security.ApiTokenProperty/generateNewToken"
  args:
    executable: /bin/bash
  register: token_response


- name: Extract token value
  set_fact:
    jenkins_api_tokens: "{{ (token_response.stdout | from_json).data.tokenValue }}"

- name: Save token
  copy:
    content: "{{ jenkins_api_token }}"
    dest: /tmp/jenkins_token_output.txt

- name: Store Jenkins API token in Vault
  ansible.builtin.shell: |
    ansible-vault encrypt_string "{{ jenkins_api_tokens }}" --name 'jenkins_api_tokens' --vault-password-file vault_pass.txt
  delegate_to: localhost
  become: false
  register: encrypted_token

- name: Update jenkins_api_token in group_vars/all.yml using replace
  ansible.builtin.replace:
    path: "{{ playbook_dir }}/group_vars/all.yml"
    regexp: '^jenkins_api_token:*'
    replace: "jenkins_api_token: {{ jenkins_api_tokens }}"
    backup: yes
  delegate_to: localhost
  become: false

- name: Wait for Jenkins to be available
  uri:
    url: "{{ jenkins_host }}/login"
    status_code: 200
    timeout: 300
    validate_certs: no
  register: jenkins_check
  until: jenkins_check.status == 200
  retries: 30
  delay: 10

- name: Read Jenkins cookie string from file
  slurp:
    src: /tmp/jenkins_cookie.txt
  register: jenkins_cookie_raw

- name: Decode and extract JSESSIONID
  set_fact:
    jenkins_cookie: "{{ (jenkins_cookie_raw.content | b64decode | regex_search('JSESSIONID[^;]+')) | regex_replace('\\s+', '') }}"



- name: Inject Jenkins secrets
  import_tasks: inject_jenkins_secrets.yml

# - name: Toggle CSRF protection (based on jenkins_csrf_enabled)
#   include_tasks: toggle_csrf.yml
  
- name: Wait for Jenkins to be available
  uri:
    url: "{{ jenkins_host }}/login"
    status_code: 200
    timeout: 300
    validate_certs: no
  register: jenkins_check
  until: jenkins_check.status == 200
  retries: 30
  delay: 10


- name: Install Jenkins plugins
  shell: |
    java -jar /tmp/jenkins-cli.jar -s {{ jenkins_host }} -auth {{ jenkins_user }}:{{ jenkins_password }} install-plugin {{ item }} -deploy
  loop:
    - script-security
    - antisamy-markup-formatter
- name: Restart Jenkins after installing plugins
  become: true
  service:
    name: jenkins
    state: restarted


- name: Get last build number before triggering
  uri:
    url: "{{ jenkins_host }}/job/{{ jenkins_pipeline }}/api/json"
    user: "{{ jenkins_user }}"
    password: "{{ jenkins_api_tokens }}"
    force_basic_auth: yes
    return_content: yes
  register: job_info_before
  changed_when: false


- name: Set last build number before triggering
  set_fact:
    last_build_number_before: "{{ job_info_before.json.lastBuild.number | default(0) | int }}"

- name: Abort running build if in progress
  uri:
    url: "{{ jenkins_host }}/job/{{ jenkins_pipeline }}/{{ last_build_number_before }}/stop"
    method: POST
    user: "{{ jenkins_user }}"
    password: "{{ jenkins_api_tokens }}"
    force_basic_auth: yes
  when: job_info_before.json.building | default(false)
  register: abort_response

- name: Wait for 30 seconds to allow build to start
  ansible.builtin.pause:
    seconds: 30

- name: Trigger Jenkins job build
  uri:
    url: "{{ jenkins_host }}/job/{{ jenkins_pipeline }}/build"
    method: POST
    user: "{{ jenkins_user }}"
    password: "{{ jenkins_api_tokens }}"
    force_basic_auth: yes
    status_code: 201
  register: trigger_result

- name: Wait for 30 seconds to allow build to start
  ansible.builtin.pause:
    seconds: 30

- name: Set new build number 
  set_fact:
    new_build_number: "{{ (last_build_number_before | default(0) + 1) | string }}"

- name: Wait for Jenkins build to start
  uri:
    url: "{{ jenkins_host }}/job/{{ jenkins_pipeline }}/{{ new_build_number }}/api/json"
    user: "{{ jenkins_user }}"
    password: "{{ jenkins_api_tokens }}"
    force_basic_auth: yes
    return_content: yes
    status_code: [200, 404]
  register: build_info
  retries: 30
  delay: 90
  until: build_info.status == 200 and build_info.json.building is defined

- name: Wait for Jenkins build to complete
  uri:
    url: "{{ jenkins_host }}/job/{{ jenkins_pipeline }}/{{ last_build_number_before + 1 }}/api/json"
    user: "{{ jenkins_user }}"
    password: "{{ jenkins_api_tokens }}"
    force_basic_auth: yes
    return_content: yes
  register: build_info
  retries: 40
  delay: 15
  until: build_info.json.building == false

- name: Fail if build did not succeed
  fail:
    msg: "Jenkins build failed or was aborted"
  when: build_info.json.result != 'SUCCESS'
